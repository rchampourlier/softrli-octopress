---
layout: post
title: "Organization for provisioning your environments (from dev to prod) with Chef"
date: 2012-05-19 11:56
comments: true
categories: [sysadmin, maintenance, unix]

---

When you start developping a project with a team, you may start facing issues requiring you to share the same development environment. I just discovered [Vagrant](www.vagrantup.com) and it's the perfect solution for doing this.

Vagrant is nice, but it stills requires you to provision your machine with the needed language stacks, services, etc. This is why it's provided with a way to hook into Chef or Puppet.

*I'll go with Chef because I had already given it a try sometime ago, and config files are written in Ruby, which I know.*

Since you're going to build recipes and/or cookbooks **to provision your development machine, what about going a little further and using Chef to provision your staging/production machines too?**

<!-- more -->

There will be differences between your development and staging/production setups. However, you will have to install the same databases, maybe some background processors and some other services, so most of the provisioning that you will prepare for your development machine can be reused to provision your staging/production machines too.

### Purpose

The purpose of this tutorial **is not to be a complete walkthrough** for doing this, since this would involve explaining how to build Chef recipes/cookbooks, running Chef-Solo, etc. It only intends to let you imagine what you could do to ease your provisioning process, knowing the tools exist and they can be used like this. Plus I propose a simple organization for your configuration files that may help you with it.

### Tools

#### Chef

Chef is a configuration manager which will read a recipe and use cookbooks to perform operations on a given machine (or node).

It has several architectures:

* **Chef Client/Server**: the node performing the operations is the Chef Client and the operations to be performed are determined thanks to a Chef Server. This solution provides some advantages because the server can remember some information on the state of each node. Opscode provides an [Hosted Chef Server](http://www.opscode.com/hosted-chef/) for free up to 5 nodes.
* **Chef Solo**: the node performing the operations is running Chef Solo and the operations to be performed are defined by local files (or a `tgz` which can be downloaded from somewhere). It's the fast way, and should be sufficient for provisioning your development machines and a few staging/production machines.

For the installation of any of the two solutions, please refer to [Opscode's documentation](http://www.opscode.com/chef/). For your Vagrant machines, no installation needed, everything is already [hooked in](http://vagrantup.com/docs/getting-started/provisioning.html).

#### Puppet

An alternative for Chef is Puppet, which can be hooked into Vagrant too. I won't detail it since I never tried it...

#### Librarian

[Librarian](https://github.com/applicationsonline/librarian) is a useful tool which will help you bundle your cookbooks.

To build your recipe and provisioning configuration, you will rely on cookbooks, most of them defined and shared by the community. You will find many on Github, the main repositories being provided by [Opscode](https://github.com/opscode-cookbooks/).

With Librarian you build a `Cheffile` and the principle is almost the same as Bundler for gems: you list the required cookbooks, you can specify their location and the version you want to use, and Librarian will gather them for you, ensuring the correct version of the cookbook is fetched, so that you won't get a broken version if it gets updated.

Once you've created the `Cheffile`, it's almost as simple as:

```
gem install librarian
librarian-chef install
```

### Organization

How to organize all this for the provisioning of machines related to your project? Here's my approach, starting with the files-tree:

```
+ project
  + machines
    + cookbooks
      ...
      <the cookbooks directories generated by Librarian>
      ...
  	+ cookbooks_local
  	  + project
  	    + recipes
  	      - default.rb
  	      - development.rb
  	      - staging.rb
  	      - production.rb
  	    - metadata.json
  	+ operations
  	  - provision_development.json
  	  - provision_staging.json
  	  - provision_production.json
  	+ roles
  	  - base.json
  	  - databases.json
  	  - maintenance.json
  	  - ruby.json
  	- Cheffile
  	- Cheffile.lock
  	- solo.rb
```

#### `cookbooks`

This is the directory of cookbooks generated by Librarian according to the content of your `Cheffile`.

Please notice the `Cheffile.lock` file which will keep the references to the cookbooks versions you have actually installed. This allows you to restore the `cookbooks` directory with the same versions of the cookbooks even if you did not specified particular versions of the cookbooks. This way, you don't need to commit your `cookbooks` directory with your versioning system.

#### `cookbooks_local`

This directory contains the cookbooks you maintain yourself and that you will use to setup your own environments.

Inside, I have a `project` cookbook containing recipes for any of the different environments I have to setup: development, staging, production.

The best way to build this cookbook is to look at others, and customize as needed. I have a `metadata.json` which describes the cookbook. I'm not sure it's required, but I think it's better to have it.

#### `operations`

When you want Chef to perform operations on a node, you provide it with a *run list* and some *attributes*. For Chef Client/Server, this is defined on the server. For Chef Solo, you generally provide the `chef-solo` command with a JSON file (often named `dna.json`).

Here instead of one `dna.json` file, I keep several files allowing me to run different sets of operations. For example here is the content of my `provision_development.json` file:

```javascript
{
  "run_list": [
    "role[base]",
    "role[ruby]",
    "role[databases]",
    "recipe[project::development]"
  ],
  
  "ruby_stack": {
    "rubies": ["1.9.2-p290"],
    "global": "1.9.2-p290",
    "users": "vagrant"
  },

  "postgresql": {
    "password": {
      "postgres": "password"
    }
  }
}
```
This file provides Chef-Solo with a run list, which will run several roles (defined in the different JSON files under `roles` and described in the next paragraph), recipes, and define the attributes that may be required by the different recipes.

Why several configuration files? Because for my production environment, I will want to run another role: `role[maintenance]`  which will provision a set of tools to help me with maintenance tasks, and use another recipe for the project's specific provisioning: `recipe[project::production]`.

#### `roles`

The roles are a simple concept allowing you to bundle a set of recipes together.

Here is our `base.json` role file:

```
{
  "name": "base",
  "description": "Base role applied to all nodes.",
  "chef_type": "role",
  "json_class": "Chef::Role",

  "run_list": [
    "recipe[apt]",
    "recipe[build-essential]",
    "recipe[git]"
  ]
}
```

As you can see, it allows us to group several recipes depending on the role of the machine:

* `base` will be provisioned on all nodes,
* `ruby` will be provisioned for nodes requiring it,
* `databases` will be provisioned for nodes acting as databases servers,
* etc.

#### Cheffile

That's the file used by Librarian to get the required cookbooks. It takes this form:

```
site "http://community.opscode.com/api/v1"

cookbook "apt"
cookbook 'build-essential'
cookbook 'git'
...
cookbook 'ruby_build',
  :git => 'https://github.com/fnichol/chef-ruby_build.git',
  :ref => 'v0.6.2'

```

The first line starting with `site` allows you to get the cookbooks from Opscode community easily. You can also specify a location (git, local), for the cookbooks not available on this community. Just check [Librarian's documentation](https://github.com/applicationsonline/librarian).

#### `solo.rb`

That's the configuration file we use to run Chef-Solo. Here is the content for this configuration:

```
# chef-solo -c ./solo.rb -j ./operations/operation.json
file_cache_path "/tmp/chef"
cookbook_path [File.expand_path('../cookbooks', __FILE__), File.expand_path('../cookbooks_local', __FILE__)]
role_path "#{File.expand_path('../roles', __FILE__)}"
log_level :info
log_location STDOUT
ssl_verify_mode :verify_none

```

Notice the `cookbook_path` which is provided with an Array containing both the `cookbooks` and the `cookbooks_local` directories.

### Time to run

Assuming you have Chef-Solo installed on the machine you want to run the operations on, you should be good with running:

```
cd <your-project>
cd machines
[sudo] chef-solo -c ./solo.rb -j ./operations/<operation>.json
```

Be sure to have installed the cookbooks before however (see the Librarian paragraph if you don't now what to do).